/*
 * ml_kernels.hpp
 *
 *  Created on: 7/05/2015
 *      Author: bsp
 */

#ifndef VIENNACL_ML_OPENCL_ML_KERNELS_HPP_
#define VIENNACL_ML_OPENCL_ML_KERNELS_HPP_

#include <viennacl/ocl/context.hpp>

namespace viennacl
{
	namespace ml
	{
		namespace opencl
		{
			struct ml_helper_kernels
			{
				static std::string program_name()
				{
				    return "ml_helpers";
				}

				static void init(viennacl::ocl::context& ctx)
				{
					static bool done = false; // TODO : multiple hsa contexts. At the moment there can be only one
					if (done)
						return;
					done = true;
					std::string code;
					code.reserve(1024);

					const char* const pragmas =
							"\n#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
							"\n#pragma OPENCL EXTENSION cl_khr_int64_base_atomics : enable\n"
							"\n#pragma OPENCL EXTENSION cl_khr_int64_extended_atomics : enable\n"
							"\n#define WAVEFRONT_SIZE 64\n";
					code.append(pragmas);

					const char* const index =
							"\n#define IDX(row,col,A_start1, A_stride1, A_start2,A_stride2,  A_internal_size2) (A_start1 + A_stride1 * row) * A_internal_size2 + (A_start2 + A_stride2 * col)\n";

					code.append(index);

					const char* const scan_inclusive =
							"__kernel void create_histogram(__global const double* data, __global double* result, uint bin_size) "
							"{ "
							"  uint lid = get_local_id(0); "
							"  uint binId = get_group_id(0); "
							"  uint group_offset = binId * bin_size; "
							"  uint maxval = data[get_local_id(0)]; "
							"  do "
							"  { "
							"		uint binValue = data[group_offset + lid]; "
							"       uint prefix_sum = work_group_scan_exclusive_add( binValue ); "
							"       result[group_offset + lid] = prefix_sum + maxval; "
							"       maxval += work_group_broadcast( prefix_sum + binValue, get_local_size(0)-1 ); "
							"       group_offset += get_local_size(0);"
							"                                         "
							"  } while(group_offset < (binId+1) * bin_size);"
							" }";
					code.append(scan_inclusive);

					const char* const reduce =
							"\n__global volatile atomic_int global_barrier = ATOMIC_VAR_INIT(0); \n"
							"\n__kernel void reduce(ulong N, __local double* local_buffer, __global const double* in, __global double* result)"
							"{"
							  "int barrier_unset = 0;"
							  // Get our global thread ID
							  "int id = get_global_id(0);"
							  "const int lid = get_local_id(0);"
							  "const int group_size = get_local_size(0);"
							  "local_buffer[lid] = 0;"
							  "for (int idx = id; idx < N; idx+= get_global_size(0))"
							  "  local_buffer[lid]+= in[idx];"
							  "double tmp =  local_buffer[lid];"
							  "barrier(CLK_LOCAL_MEM_FENCE);"
							  // local memory reduction
							  "int i = group_size/2;"
							  "for(; i>WAVEFRONT_SIZE; i >>= 1) {"
								  "if(lid < i)"
									  "local_buffer[lid] = tmp = tmp + local_buffer[lid + i];"
								  "barrier(CLK_LOCAL_MEM_FENCE);"
							  "}"
							  // wavefront reduction
							  "for(; i>0; i >>= 1) {"
							  "	if(lid < i) "
							  " 	local_buffer[lid] = tmp = tmp + local_buffer[lid + i];"
							  "}"

							  "if(lid==0) {"
							  //"     if (get_global_id(0) == 0) result[0] = 0;"
							  " 	while (!atomic_compare_exchange_weak(&global_barrier, &barrier_unset, 1))"
							  "		{ barrier_unset = 0;}"
							  " 	result[0] += tmp;"
							  " 	atomic_exchange(&global_barrier, 0);"
							  "}"
							"}\n";
					code.append(reduce);


					// for row = [0.. row_count] - update rows with factor results
					const char* const sparse_matrix_by_constant = "\n"
							"__kernel  void sgd_update_weights(ulong N, __global double* elements,__global double * factors, __global int* rows, __global int * columns, __global atomic_int* locks, __global double* output)"
							"{"
							"    int barrier_unset = 0; "
							"    int id = get_global_id(0);  "
							"    for (; id < N; id+= get_global_size(0)) "
							"    {                "
							"		if (factors[id] != 0)                "
							"       {										"
							"    		int start = rows[ id ];              "
							"			int end = rows[ id +1];     "
							"			for (int i = start; i < end; ++i)  "
							"			{             "
							"				int idx = columns[i];                          				         "
								"			double upd = elements[i] * factors[id];       "
							"				while (!atomic_compare_exchange_weak(&locks[idx], &barrier_unset, 1)) { barrier_unset = 0; }"
							"				output[idx] += upd;\n"
							"           	atomic_exchange(&locks[idx], 0); "
							"	  	   }                                                    "
							"       }             "
							"    }"
							"}\n";

					code.append(sparse_matrix_by_constant);

					const char* const map_prod_value_nominal ="\n"
							"\n__kernel void sgd_map_prod_value(ulong N, uint nominal,uint loss_function, double learning_rate, double bias, __global double* class_values, __global double* prod_values, __global double* factor)\n"
							"{\n"
							"	int id = get_global_id(0);\n"
							"   double y;                 "
							"   double z;                  "
							"	for (; id < N; id+= get_global_size(0))\n "
							"   {														 "
							"       if (nominal)\n"
							"		{	"
							"			y = select(-1,1, (int)class_values[id]); "
							"			z = y*(prod_values[id]  + bias);"
							"		}"
							"		else\n"
							"		{"
							"			y = class_values[id]; "
							"			z =  y - (prod_values[id] + bias);\n"
							"		}\n"
							"		double loss = 0;   "
							"       switch(loss_function)    "
							"       {"
							"          case 0: loss = isless(z, 1);"
							"				break; "
							"          case 1:"
							"		   {"
							"	        double t = exp(-z); "
							"			loss = fmin(1.0 / (exp(z) + 1.0),t / (t+1)); "
							"		   }"
							"          break;"
							"          case 2:"
							"          {"
							"            loss = z;"
							"          }"
							"          break;"
							"		}"
							"       factor[id] = learning_rate * y * loss;"
							"	}"
							"}\n";
					code.append(map_prod_value_nominal);
					const char* const knn_calc_distance =
							"\n__kernel void knn_calc_distance(int start_row, int end_row, ulong instance_length, __global double* samples,"
							"uint samples_start1, uint samples_start2, uint samples_internal_size1, uint samples_internal_size2, uint samples_size1, "
							"uint samples_size2, uint samples_stride1, uint samples_stride2, "
							" __global double* min, __global double* max, __global int* types, __global double* test, __global double* result)"
							"{\n"
							" 	for (int id = get_global_id(0) + start_row;id < end_row; id += get_global_size(0) )"
							" 	{"
							"       double cur = 0;"
							"		for(int offset = id; offset < id+instance_length ; ++offset)"
							"       {"
							"           int idx = offset -id;"
							"           double diff = max[idx] - min[idx];"
							"           int loc =  IDX(id,idx,samples_start1, samples_stride1, samples_start2, samples_stride2, samples_internal_size2);"
							"			double d =  (samples[loc]  - test[idx])/diff;"
							"			if (types[idx] > 0 ) "
							"				 cur += d != 0 ? 1 : 0;"
							"			else"
							"				 cur += d*d; "
							"		}"
							"		result[id-start_row] = cur; "
							" 	} "
							"}\n" ;

					code.append(knn_calc_distance);



					const char* const bitonic_sort =

							"\n/* Bitonic Sort kernel after OpenCL in Action by Matt Scarpino*/\n"
							"\n/* Sort elements within a vector */\n"
							"\n#define VECTOR_SORT(input, dir, indices)                          \\n"
							"    comp = input < shuffle(input, mask2) ^ dir;                    \\n"
							"    input = shuffle(input, as_uint4(comp * 2 + add2));             \\n"
							"    indices = shuffle( indices, as_uint4(comp*2 + add2));          \\n"
							"    comp = input < shuffle(input, mask1) ^ dir;                    \\n"
							"    input = shuffle(input, as_uint4(comp + add1));                 \\n"
							"    indices = shuffle(indices, as_uint4(comp + add1));             \\n"
							"    \n"
							"\n\n"
							"\n#define VECTOR_SWAP(input1, input2, dir, indices1,indices2)       \\n"
							"    temp = input1;                                                 \\n"
							"    temp_indices = indices1;                                       \\n"
							"    comp = (input1 < input2 ^ dir) * 4 + add3;                     \\n"
							"    input1 = shuffle2(input1, input2, as_uint4(comp));             \\n"
							"    input2 = shuffle2(input2, temp, as_uint4(comp));               \\n"
							"    indices1 = shuffle2( indices1, indices2, as_uint4(comp));      \\n"
							"    indices2 = shuffle2( indices2, temp_indices, as_uint4(comp));  \\n"
							"\n   \n"
							"\n\n"
							"\n/* Perform initial sort */\n"
							"\n__kernel void bsort_init(__global double4 *g_data,  __local double4 *l_data, __global int4* g_indices, __local int4* l_indices) {\n"
							"\n\n"
							"\n   int dir;\n"
							"\n   uint id, global_start, size, stride;\n"
							"\n   double4 input1, input2, temp;\n"
							"\n   int4 indices1, indices2, temp_indices;\n"
							"\n   \n"
							"\n   int4 comp;\n"
							"\n\n"
							"\n   uint4 mask1 = (uint4)(1, 0, 3, 2);\n"
							"\n   uint4 mask2 = (uint4)(2, 3, 0, 1);\n"
							"\n   uint4 mask3 = (uint4)(3, 2, 1, 0);\n"
							"\n\n"
							"\n   int4 add1 = (int4)(1, 1, 3, 3);\n"
							"\n   int4 add2 = (int4)(2, 3, 2, 3);\n"
							"\n   int4 add3 = (int4)(1, 2, 2, 3);\n"
							"\n   \n"
							"\n   int gid = get_global_id(0) * 8;\n"
							"\n\n"
							"\n   id = get_local_id(0) * 2;\n"
							"\n   global_start = get_group_id(0) * get_local_size(0) * 2 + id;\n"
							"\n\n"
							"\n   input1 = g_data[global_start]; \n"
							"\n   input2 = g_data[global_start+1];\n"
							"\n   \n"
							"\n   indices1 = (int4)( gid, gid + 1, gid + 2 , gid +3); \n"
							"\n   indices2 = (int4)( gid+4, gid + 5, gid +6, gid +7);\n"
							"\n   \n"
							"\n   \n"
							"\n\n"
							"\n   /* Sort input 1 - ascending */\n"
							"\n   comp = input1 < shuffle(input1, mask1);\n"
							"\n   \n"
							"\n   input1 = shuffle(input1, as_uint4(comp + add1));\n"
							"\n   indices1 = shuffle( indices1, as_uint4( comp + add1));\n"
							"\n   \n"
							"\n   comp = input1 < shuffle(input1, mask2);\n"
							"\n   input1 = shuffle(input1, as_uint4(comp * 2 + add2));\n"
							"\n   indices1 = shuffle(indices1, as_uint4(comp*2 + add2));\n"
							"\n   \n"
							"\n   comp = input1 < shuffle(input1, mask3);\n"
							"\n   input1 = shuffle(input1, as_uint4(comp + add3));\n"
							"\n   indices1 = shuffle(indices1, as_uint4( comp + add3));\n"
							"\n\n"
							"\n   /* Sort input 2 - descending */\n"
							"\n   comp = input2 > shuffle(input2, mask1);\n"
							"\n   input2 = shuffle(input2, as_uint4(comp + add1));\n"
							"\n   indices2 = shuffle(indices2, as_uint4(comp + add1));\n"
							"\n   \n"
							"\n   comp = input2 > shuffle(input2, mask2);\n"
							"\n   input2 = shuffle(input2, as_uint4(comp * 2 + add2));\n"
							"\n   indices2 = shuffle(indices2, as_uint4(comp * 2 + add2));\n"
							"\n   \n"
							"\n   comp = input2 > shuffle(input2, mask3);\n"
							"\n   input2 = shuffle(input2, as_uint4(comp + add3));     \n"
							"\n   indices2 = shuffle(indices2, as_uint4(comp + add3));\n"
							"\n\n"
							"\n   /* Swap corresponding elements of input 1 and 2 */\n"
							"\n   add3 = (int4)(4, 5, 6, 7);\n"
							"\n   dir = get_local_id(0) % 2 * -1;\n"
							"\n   temp = input1;\n"
							"\n   temp_indices = indices1;\n"
							"\n   \n"
							"\n   comp = (input1 < input2 ^ dir) * 4 + add3;\n"
							"\n   \n"
							"\n   input1 = shuffle2(input1, input2, as_uint4(comp));\n"
							"\n   indices1 = shuffle2(indices1, indices2, as_uint4(comp));\n"
							"\n   \n"
							"\n   input2 = shuffle2(input2, temp, as_uint4(comp));\n"
							"\n   indices2 = shuffle2(indices2, temp_indices, as_uint4(comp));\n"
							"\n\n"
							"\n   /* Sort data and store in local memory */\n"
							"\n   VECTOR_SORT(input1, dir, indices1);\n"
							"\n   VECTOR_SORT(input2, dir, indices2);\n"
							"\n   \n"
							"\n   l_data[id] = input1;\n"
							"\n   l_indices[id] = indices1;\n"
							"\n   \n"
							"\n   l_data[id+1] = input2;\n"
							"\n   l_indices[id+1] = indices2;\n"
							"\n\n"
							"\n   /* Create bitonic set */\n"
							"\n   for(size = 2; size < get_local_size(0); size <<= 1) {\n"
							"\n      dir = (get_local_id(0)/size & 1) * -1;\n"
							"\n\n"
							"\n      for(stride = size; stride > 1; stride >>= 1) {\n"
							"\n         barrier(CLK_LOCAL_MEM_FENCE);\n"
							"\n         id = get_local_id(0) + (get_local_id(0)/stride)*stride;\n"
							"\n         VECTOR_SWAP(l_data[id], l_data[id + stride], dir, l_indices[id], l_indices[id+stride])\n"
							"\n      }\n"
							"\n\n"
							"\n      barrier(CLK_LOCAL_MEM_FENCE);\n"
							"\n      id = get_local_id(0) * 2;\n"
							"\n      \n"
							"\n      input1 = l_data[id];\n"
							"\n      indices1 = l_indices[id];\n"
							"\n       \n"
							"\n      input2 = l_data[id+1];\n"
							"\n      indices2 = l_indices[id+1];\n"
							"\n      \n"
							"\n      temp = input1;\n"
							"\n      temp_indices = indices1;\n"
							"\n      \n"
							"\n      comp = (input1 < input2 ^ dir) * 4 + add3;\n"
							"\n      \n"
							"\n      input1 = shuffle2(input1, input2, as_uint4(comp));\n"
							"\n      indices1 = shuffle2(indices1, indices2, as_uint4(comp));\n"
							"\n      \n"
							"\n      input2 = shuffle2(input2, temp, as_uint4(comp));\n"
							"\n      indices2 = shuffle2(indices2, temp_indices, as_uint4(comp));\n"
							"\n      \n"
							"\n      VECTOR_SORT(input1, dir, indices1);\n"
							"\n      VECTOR_SORT(input2, dir, indices2);\n"
							"\n      \n"
							"\n      l_data[id] = input1;\n"
							"\n   	  l_indices[id] = indices1;\n"
							"\n   \n"
							"\n   	  l_data[id+1] = input2;\n"
							"\n   	  l_indices[id+1] = indices2;\n"
							"\n   }\n"
							"\n\n"
							"\n   /* Perform bitonic merge */\n"
							"\n   dir = (get_group_id(0) % 2) * -1;\n"
							"\n   for(stride = get_local_size(0); stride > 1; stride >>= 1) {\n"
							"\n      barrier(CLK_LOCAL_MEM_FENCE);\n"
							"\n      id = get_local_id(0) + (get_local_id(0)/stride)*stride;\n"
							"\n      VECTOR_SWAP(l_data[id], l_data[id + stride], dir, l_indices[id], l_indices[id+stride])\n"
							"\n   }\n"
							"\n   barrier(CLK_LOCAL_MEM_FENCE);\n"
							"\n\n"
							"\n   /* Perform final sort */\n"
							"\n   id = get_local_id(0) * 2;\n"
							"\n   \n"
							"\n      input1 = l_data[id];\n"
							"\n      indices1 = l_indices[id];\n"
							"\n       \n"
							"\n      input2 = l_data[id+1];\n"
							"\n      indices2 = l_indices[id+1];\n"
							"\n      \n"
							"\n      temp = input1;\n"
							"\n      temp_indices = indices1;\n"
							"\n      \n"
							"\n      comp = (input1 < input2 ^ dir) * 4 + add3;\n"
							"\n      \n"
							"\n      input1 = shuffle2(input1, input2, as_uint4(comp));\n"
							"\n      indices1 = shuffle2(indices1, indices2, as_uint4(comp));\n"
							"\n      \n"
							"\n      input2 = shuffle2(input2, temp, as_uint4(comp));\n"
							"\n      indices2 = shuffle2(indices2, temp_indices, as_uint4(comp));\n"
							"\n      \n"
							"\n      VECTOR_SORT(input1, dir, indices1);\n"
							"\n      VECTOR_SORT(input2, dir, indices2);\n"
							"\n      \n"
							"\n   g_indices[global_start] = indices1;\n"
							"\n   g_indices[global_start+1] = indices2;\n"
							"\n         \n"
							"\n   g_data[global_start] = input1;\n"
							"\n   g_data[global_start+1] = input2;\n"
							"\n}\n"
							"\n\n"
							"\n/* Perform lowest stage of the bitonic sort */\n"
							"\n__kernel void bsort_stage_0(__global double4 *g_data, __local double4 *l_data, \n"
							"\n                            uint high_stage, __global int4* g_indices, __local int4* l_indices) {\n"
							"\n\n"
							"\n   int dir;\n"
							"\n   uint id, global_start, stride;\n"
							"\n   double4 input1, input2, temp;\n"
							"\n   int4 indices1, indices2, temp_indices;\n"
							"\n   int4 comp;\n"
							"\n\n"
							"\n   uint4 mask1 = (uint4)(1, 0, 3, 2);\n"
							"\n   uint4 mask2 = (uint4)(2, 3, 0, 1);\n"
							"\n   uint4 mask3 = (uint4)(3, 2, 1, 0);\n"
							"\n\n"
							"\n   int4 add1 = (int4)(1, 1, 3, 3);\n"
							"\n   int4 add2 = (int4)(2, 3, 2, 3);\n"
							"\n   int4 add3 = (int4)(4, 5, 6, 7);\n"
							"\n\n"
							"\n   /* Determine data location in global memory */\n"
							"\n   id = get_local_id(0);\n"
							"\n   dir = (get_group_id(0)/high_stage & 1) * -1;\n"
							"\n   global_start = get_group_id(0) * get_local_size(0) * 2 + id;\n"
							"\n\n"
							"\n   /* Perform initial swap */\n"
							"\n   input1 = g_data[global_start];\n"
							"\n   input2 = g_data[global_start + get_local_size(0)];\n"
							"\n   \n"
							"\n   indices1 = g_indices[global_start];\n"
							"\n   indices2 = g_indices[global_start + get_local_size(0)];\n"
							"\n   \n"
							"\n   comp = (input1 < input2 ^ dir) * 4 + add3;\n"
							"\n   \n"
							"\n   l_data[id] = shuffle2(input1, input2, as_uint4(comp));\n"
							"\n   l_data[id + get_local_size(0)] = shuffle2(input2, input1, as_uint4(comp));\n"
							"\n   \n"
							"\n   l_indices[id] = shuffle2(indices1, indices2, as_uint4(comp));\n"
							"\n   l_indices[id + get_local_size(0)] = shuffle2(indices2, indices1, as_uint4(comp));\n"
							"\n   \n"
							"\n\n"
							"\n   /* Perform bitonic merge */\n"
							"\n   for(stride = get_local_size(0)/2; stride > 1; stride >>= 1) {\n"
							"\n      barrier(CLK_LOCAL_MEM_FENCE);\n"
							"\n      id = get_local_id(0) + (get_local_id(0)/stride)*stride;\n"
							"\n      VECTOR_SWAP(l_data[id], l_data[id + stride], dir, l_indices[id], l_indices[id+stride])\n"
							"\n   }\n"
							"\n   barrier(CLK_LOCAL_MEM_FENCE);\n"
							"\n\n"
							"\n   /* Perform final sort */\n"
							"\n   id = get_local_id(0) * 2;\n"
							"\n   \n"
							"\n   input1 = l_data[id]; \n"
							"\n   input2 = l_data[id+1];\n"
							"\n   \n"
							"\n   indices1 = l_indices[id];\n"
							"\n   indices2 = l_indices[id+1];\n"
							"\n      \n"
							"\n   temp = input1;\n"
							"\n   temp_indices = indices1;\n"
							"\n   \n"
							"\n   comp = (input1 < input2 ^ dir) * 4 + add3;\n"
							"\n   input1 = shuffle2(input1, input2, as_uint4(comp));\n"
							"\n   input2 = shuffle2(input2, temp, as_uint4(comp));\n"
							"\n   \n"
							"\n   indices1 = shuffle2(indices1, indices2, as_uint4(comp));\n"
							"\n   indices2 = shuffle2(indices2, temp_indices, as_uint4(comp));\n"
							"\n   VECTOR_SORT(input1, dir, indices1);\n"
							"\n   VECTOR_SORT(input2, dir, indices2);\n"
							"\n\n"
							"\n   /* Store output in global memory */\n"
							"\n   g_indices[global_start + get_local_id(0)] = indices1;\n"
							"\n   g_indices[global_start + get_local_id(0) + 1] = indices2;\n"
							"\n   \n"
							"\n   g_data[global_start + get_local_id(0)] = input1;\n"
							"\n   g_data[global_start + get_local_id(0) + 1] = input2;\n"
							"\n}\n"
							"\n\n"
							"\n/* Perform successive stages of the bitonic sort */\n"
							"\n__kernel void bsort_stage_n(__global double4 *g_data, __local double4 *l_data, \n"
							"\n                            uint stage, uint high_stage, __global int4* g_indices, __local int4* l_indices) {\n"
							"\n\n"
							"\n   int dir;\n"
							"\n   double4 input1, input2;\n"
							"\n   int4 indices1, indices2;\n"
							"\n   int4 comp, add;\n"
							"\n   uint global_start, global_offset;\n"
							"\n\n"
							"\n   add = (int4)(4, 5, 6, 7);\n"
							"\n\n"
							"\n   /* Determine location of data in global memory */\n"
							"\n   dir = (get_group_id(0)/high_stage & 1) * -1;\n"
							"\n   global_start = (get_group_id(0) + (get_group_id(0)/stage)*stage) *\n"
							"\n                   get_local_size(0) + get_local_id(0);\n"
							"\n   global_offset = stage * get_local_size(0);\n"
							"\n\n"
							"\n   /* Perform swap */\n"
							"\n   input1 = g_data[global_start];\n"
							"\n   input2 = g_data[global_start + global_offset];\n"
							"\n   \n"
							"\n   indices1 = g_indices[global_start];\n"
							"\n   indices2 = g_indices[global_start + global_offset];\n"
							"\n   \n"
							"\n   comp = (input1 < input2 ^ dir) * 4 + add;\n"
							"\n   \n"
							"\n   g_data[global_start] = shuffle2(input1, input2, as_uint4(comp));\n"
							"\n   g_data[global_start + global_offset] = shuffle2(input2, input1, as_uint4(comp));\n"
							"\n   \n"
							"\n   g_indices[global_start] = shuffle2(indices1, indices2, as_uint4(comp));\n"
							"\n   g_indices[global_start + global_offset] = shuffle2(indices2, indices1, as_uint4(comp));\n"
							"\n}\n"
							"\n\n"
							"\n/* Sort the bitonic set */\n"
							"\n__kernel void bsort_merge(__global double4 *g_data, __local double4 *l_data, uint stage, int dir, __global int4* g_indices, __local int4* l_indices) {\n"
							"\n\n"
							"\n   double4 input1, input2;\n"
							"\n   int4 indices1, indices2;\n"
							"\n   int4 comp, add;\n"
							"\n   uint global_start, global_offset;\n"
							"\n\n"
							"\n   add = (int4)(4, 5, 6, 7);\n"
							"\n\n"
							"\n   /* Determine location of data in global memory */\n"
							"\n   global_start = (get_group_id(0) + (get_group_id(0)/stage)*stage) *\n"
							"\n                   get_local_size(0) + get_local_id(0);\n"
							"\n   global_offset = stage * get_local_size(0);\n"
							"\n\n"
							"\n   /* Perform swap */\n"
							"\n   input1 = g_data[global_start];\n"
							"\n   input2 = g_data[global_start + global_offset];\n"
							"\n   \n"
							"\n   indices1 = g_indices[global_start];\n"
							"\n   indices2 = g_indices[global_start + global_offset];\n"
							"\n   \n"
							"\n   \n"
							"\n   comp = (input1 < input2 ^ dir) * 4 + add;\n"
							"\n   g_data[global_start] = shuffle2(input1, input2, as_uint4(comp));\n"
							"\n   g_data[global_start + global_offset] = shuffle2(input2, input1, as_uint4(comp));\n"
							"\n   \n"
							"\n   g_indices[global_start] = shuffle2(indices1, indices2, as_uint4(comp));\n"
							"\n   g_indices[global_start + global_offset] = shuffle2(indices2, indices1, as_uint4(comp));\n"
							"\n}\n"
							"\n\n"
							"\n/* Perform final step of the bitonic merge */\n"
							"\n__kernel void bsort_merge_last(__global double4 *g_data, __local double4 *l_data, int dir, __global int4* g_indices, __local int4* l_indices) {\n"
							"\n\n"
							"\n   uint id, global_start, stride;\n"
							"\n   double4 input1, input2, temp;\n"
							"\n   int4 indices1, indices2, temp_indices;\n"
							"\n   int4 comp;\n"
							"\n\n"
							"\n   uint4 mask1 = (uint4)(1, 0, 3, 2);\n"
							"\n   uint4 mask2 = (uint4)(2, 3, 0, 1);\n"
							"\n   uint4 mask3 = (uint4)(3, 2, 1, 0);\n"
							"\n\n"
							"\n   int4 add1 = (int4)(1, 1, 3, 3);\n"
							"\n   int4 add2 = (int4)(2, 3, 2, 3);\n"
							"\n   int4 add3 = (int4)(4, 5, 6, 7);\n"
							"\n\n"
							"\n   /* Determine location of data in global memory */\n"
							"\n   id = get_local_id(0);\n"
							"\n   global_start = get_group_id(0) * get_local_size(0) * 2 + id;\n"
							"\n\n"
							"\n   /* Perform initial swap */\n"
							"\n   input1 = g_data[global_start];\n"
							"\n   input2 = g_data[global_start + get_local_size(0)];\n"
							"\n   \n"
							"\n   indices1 = g_indices[global_start];\n"
							"\n   indices2 = g_indices[global_start + get_local_size(0)];\n"
							"\n   \n"
							"\n   comp = (input1 < input2 ^ dir) * 4 + add3;\n"
							"\n   l_data[id] = shuffle2(input1, input2, as_uint4(comp));\n"
							"\n   l_data[id + get_local_size(0)] = shuffle2(input2, input1, as_uint4(comp));\n"
							"\n   \n"
							"\n   l_indices[id] = shuffle2(indices1, indices2, as_uint4(comp));\n"
							"\n   l_indices[id + get_local_size(0)] = shuffle2(indices2, indices1, as_uint4(comp));\n"
							"\n   \n"
							"\n\n"
							"\n   /* Perform bitonic merge */\n"
							"\n   for(stride = get_local_size(0)/2; stride > 1; stride >>= 1) {\n"
							"\n      barrier(CLK_LOCAL_MEM_FENCE);\n"
							"\n      id = get_local_id(0) + (get_local_id(0)/stride)*stride;\n"
							"\n      VECTOR_SWAP(l_data[id], l_data[id + stride], dir, l_indices[id], l_indices[id+stride])\n"
							"\n   }\n"
							"\n   barrier(CLK_LOCAL_MEM_FENCE);\n"
							"\n\n"
							"\n   /* Perform final sort */\n"
							"\n   id = get_local_id(0) * 2;\n"
							"\n   input1 = l_data[id]; \n"
							"\n   input2 = l_data[id+1];\n"
							"\n   \n"
							"\n   indices1 = l_indices[id];\n"
							"\n   indices2 = l_indices[id+1];\n"
							"\n   \n"
							"\n   temp = input1;\n"
							"\n   temp_indices = indices1;\n"
							"\n   \n"
							"\n   comp = (input1 < input2 ^ dir) * 4 + add3;\n"
							"\n   input1 = shuffle2(input1, input2, as_uint4(comp));\n"
							"\n   input2 = shuffle2(input2, temp, as_uint4(comp));\n"
							"\n   \n"
							"\n   indices1 = shuffle2( indices1, indices2, as_uint4(comp));\n"
							"\n   indices2 = shuffle2( indices2, temp_indices, as_uint4(comp));\n"
							"\n   \n"
							"\n   VECTOR_SORT(input1, dir, indices1);\n"
							"\n   VECTOR_SORT(input2, dir, indices2);\n"
							"\n\n"
							"\n   /* Store the result to global memory */\n"
							"\n   g_data[global_start + get_local_id(0)] = input1;\n"
							"\n   g_data[global_start + get_local_id(0) + 1] = input2;\n"
							"\n   \n"
							"\n   g_indices[global_start + get_local_id(0)] = indices1;\n"
							"\n   g_indices[global_start + get_local_id(0) + 1] = indices2;\n"
							"\n   \n"
							"\n}\n";

					//code.append(bitonic_sort);

					ctx.add_program(code, program_name());




				}
			};
		}

	}
}




#endif /* VIENNACL_ML_HSA_ML_KERNELS_HPP_ */
